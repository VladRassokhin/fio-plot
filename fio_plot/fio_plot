#!/usr/bin/env python3
#
# Generates graphs from FIO output data for various IO queue depthts
#
# Output in PNG format.
#
# Requires matplotib and numpy.
#
import sys
import matplotlib.pyplot as plt
from matplotlib import cm
import matplotlib as mpl
import numpy as np
import argparse
import pprint
from datetime import datetime
from collections import defaultdict
import fiolib.dataimport as logdata
import fiolib.graph2d as graph
import fiolib.jsonimport as jsonimport
import fiolib.bar2d as bar2d
import fiolib.bar3d as bar3d


class Chart():
    None


class ThreeDee(Chart):

    def __init__(self, data, config):
        super().__init__(data, config)

        self.fig = plt.figure()
        self.ax1 = self.fig.add_subplot(111, projection='3d')
        self.fig.set_size_inches(15, 10)
        self.series = {}

    def generate_series(self, key, value, mode):

        recordset = self.return_record_set(key, value)
        self.series = {'x_series': [],
                       'y_series1': [],
                       'y_series2': [],
                       'y_series3': [],
                       }

        self.series['x_series'] = self.return_unique_series(
            self.config['x_series'])

        for x in self.series['x_series']:
            for y in recordset:
                if int(y[self.config['x_series']]) == int(x):
                    if mode == y['rw']:
                        self.series['y_series1'].append(
                            round(y['iops']))  # iops
                        self.series['y_series2'].append(
                            round(int(y['numjobs'])))  # lat

    def plot_3d(self, mode, metric):

        iodepth = self.return_unique_series('iodepth')
        numjobs = self.return_unique_series('numjobs')

        datatype = metric

        dataset = self.filter_record_set(self.data, 'rw', mode)
        mylist = []
        for x in numjobs:
            if x <= int(self.config['maxjobs']):
                dx = self.return_record_set(dataset, 'numjobs', x)
                d = self.subselect_record_set(
                    dx, ['numjobs', 'iodepth', datatype])
                row = []
                for y in iodepth:
                    if y <= int(self.config['maxdepth']):
                        for record in d:
                            if int(record['iodepth']) == int(y):
                                row.append(record[datatype])
                mylist.append(row)
        n = np.array(mylist, dtype=float)
        if metric == 'lat':
            n = np.divide(n, 1000000)

        lx = len(n[0])
        ly = len(n[:, 0])

        size = lx * 0.05  # thickness of the bar

        xpos_orig = np.arange(0, lx, 1)
        ypos_orig = np.arange(0, ly, 1)

        xpos = np.arange(0, lx, 1)
        ypos = np.arange(0, ly, 1)
        xpos, ypos = np.meshgrid(xpos-(size/lx), ypos-(size))

        xpos_f = xpos.flatten()   # Convert positions to 1D array
        ypos_f = ypos.flatten()
        zpos = np.zeros(lx*ly)

        dx = size * np.ones_like(zpos)
        dy = dx.copy()
        dz = n.flatten()
        values = dz / (dz.max()/1)
        cmap = plt.get_cmap('rainbow', xpos.ravel().shape[0])
        colors = cm.rainbow(values)

        self.ax1.bar3d(xpos_f, ypos_f, zpos, dx, dy, dz, color=colors)

        # color bar legend
        norm = mpl.colors.Normalize(vmin=0, vmax=dz.max())
        sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
        sm.set_array([])
        res = self.fig.colorbar(sm, fraction=0.046, pad=0.04)
        res.ax.set_title(metric)

        # axis ticks and tick labels

        float_x = [float(x) for x in (xpos_orig)]
        # unused? float_y = [float(y) for y in (ypos_orig)]

        self.ax1.w_xaxis.set_ticks(float_x)
        self.ax1.w_yaxis.set_ticks(ypos_orig)

        self.ax1.w_xaxis.set_ticklabels(iodepth)
        self.ax1.w_yaxis.set_ticklabels(numjobs)

        # self.ax1.set_zlim3d(0,int(self.config['zmax']))

        # zticks = np.arange(dz.min(), dz.max(), ((dz.max()/10)%1000))
        # self.ax1.w_zaxis.set_ticks(zticks)

        # axis labels
        fontsize = 14
        self.ax1.set_xlabel('iodepth', fontsize=fontsize)
        self.ax1.set_ylabel('numjobs', fontsize=fontsize)
        self.ax1.set_zlabel(datatype,  fontsize=fontsize)

        self.ax1.xaxis.labelpad = 10
        self.ax1.zaxis.labelpad = 20
        self.ax1.zaxis.set_tick_params(pad=10)

        # title
        mode = self.test_types[mode]
        metric = self.test_types[metric]
        plt.suptitle(self.config['title'] + " | " + mode + " | " +
                     metric, fontsize=16, horizontalalignment='center')

        # source
        self.fig.text(0.75, 0.03, self.config['source'])

        plt.tight_layout()
        plt.savefig('3d-iops-jobs' + str(mode) + "-" + str(self.date) + '.png')
        plt.close('all')


class LH_Chart(Chart):

    def sort_latency_keys(self, latency):
        placeholder = ""
        tmp = []
        for item in latency:
            if item == '>=2000':
                placeholder = ">=2000"
            else:
                tmp.append(item)

        tmp.sort(key=int)
        if(placeholder):
            tmp.append(placeholder)
        return tmp

    def sort_latency_data(self, latency_dict):

        keys = latency_dict.keys()
        values = []
        sorted_keys = self.sort_latency_keys(keys)
        for key in sorted_keys:
            values.append(latency_dict[key])
        return values

    def generate_history_chart(self, chartdata):

        x_series = chartdata['x_series']
        y_series1 = chartdata['y_series1']
        y_series2 = chartdata['y_series2']
        depth = chartdata['iodepth']
        mode = chartdata['mode']

        coverage_ms = round(sum(y_series1), 2)
        coverage_us = round(sum(y_series2), 2)

        # Creating actual graph

        fig, (ax1, ax2) = plt.subplots(
            nrows=2, gridspec_kw={'height_ratios': [11, 1]})
        fig.set_size_inches(10, 6)

        x_pos = np.arange(0, len(x_series) * 2, 2)
        width = 1

        rects1 = ax1.bar(x_pos, y_series1, width, color='r')
        rects2 = ax1.bar(x_pos + width, y_series2, width, color='b')

        ax1.set_ylabel('Percentage of IO (ms)')
        ax1.set_xlabel(r'$Latency\ in\ ms\ or\ \mu$')
        ax1.set_title(str(self.config['title']) + " | "
                      + str(mode).title() +
                      ' latency histogram | IO depth ' +
                      str(depth))
        ax1.set_xticks(x_pos + width / 2)
        ax1.set_xticklabels(x_series)

        if coverage_ms < 1 and coverage_ms > 0:
            coverage_ms = "<1"
        if coverage_us < 1 and coverage_us > 0:
            coverage_us = "<1"

        ax2.legend((rects1[0], rects2[0]), (
            'Latency in ms (' + str(coverage_ms) + '%)',
            'Latency in us  (' + str(coverage_us) + '%)'), frameon=False,
            loc='upper left')
        ax2.axis('off')

        def autolabel(rects, axis):
            for rect in rects:
                height = rect.get_height()
                if height >= 1:
                    axis.text(rect.get_x() + rect.get_width() / 2., 1.02 *
                              height, '{}%'.format(int(height)),
                                      ha='center')
                elif height > 0:
                    axis.text(rect.get_x() + rect.get_width() /
                              2., 1.02 * height, '<1%', ha='center')

        autolabel(rects1, ax1)
        autolabel(rects2, ax1)

        plt.tight_layout()

        plt.savefig(mode + "_" + str(depth) + '_histogram.png')
        plt.close('all')

    def plot_latency_histogram(self, mode):

        # not used? latency_data = self.data

        iodepth = self.return_unique_series('iodepth')
        # numjobs = self.return_unique_series('numjobs')
        numjobs = ['1']

        datatypes = ('latency_ms', 'latency_us', 'latency_ns')

        dataset = self.filter_record_set(self.data, 'rw', mode)
        mydict = defaultdict(dict)

        # pprint.pprint(dataset)

        for datatype in datatypes:
            for x in numjobs:
                dx = self.return_record_set(dataset, 'numjobs', x)
                d = self.subselect_record_set(
                    dx, ['numjobs', 'iodepth', datatype])
                for y in iodepth:
                    for record in d:
                        if int(record['iodepth']) == int(y):
                            mydict[datatype][int(y)] = record[datatype]
        for depth in iodepth:

            x_series = []
            y_series1 = []
            y_series2 = []
            y_series3 = []

            temporary = mydict['latency_ms'][1].keys()
            x_series = self.sort_latency_keys(temporary)
            y_series1 = self.sort_latency_data(mydict['latency_ms'][depth])
            y_series2 = self.sort_latency_data(mydict['latency_us'][depth])
            y_series3 = self.sort_latency_data(mydict['latency_ns'][depth])
            y_series2.append(0)
            y_series2.append(0)

            chart_data = {
                'x_series': x_series,
                'y_series1': y_series1,
                'y_series2': y_series2,
                'y_series3': y_series3,
                'iodepth': depth,
                'numjobs': 1,
                'mode': mode

            }

            self.generate_history_chart(chart_data)


def set_arguments():

    parser = argparse.ArgumentParser(description="Convert FIO JSON output \
            to charts")
    ag = parser.add_argument_group(title="Generic Settings")
    ag.add_argument("-i", "--input-directory", help="input directory where\
            JSON files can be found")
    ag.add_argument("-t", "--title", help="specifies title to use in charts")
    ag.add_argument("-s", "--source", help="Author")
    ag.add_argument("-L", "--latency_iops_3d", action='store_true', help="\
            generate latency + iops 3d")
    ag.add_argument("-l", "--latency_iops_2d", action='store_true', help="\
            generate latency + iops 2d graph")
    ag.add_argument("-H", "--histogram", action='store_true', help="\
            generate latency histogram per queue depth")
    ag.add_argument("--disable-grid", action='store_true', help="\
            disable the dotted grid in the output png")
    ag.add_argument("--enable-markers", action='store_true', help="\
            enable markers for the plot lines")
    ag.add_argument("--subtitle", help="\
            specify your own subtitle or leave it blank with double quotes", type=str, default=None)
    ag.add_argument("-I", "--iodepth", type=int, nargs='+', default=1, help="\
            iodepth to graph")
    ag.add_argument("-D", "--maxdepth", nargs='?', default=64, type=int, help="\
            maximum queue depth to graph")
    ag.add_argument("-d", "--dpi", help="\
            dpi of output png", nargs='?', default=200, type=int)
    ag.add_argument("-p", "--percentile", help="\
            calculate percentile, default 99.9th", nargs='?', default=99, type=float)
    ag.add_argument("-J", "--maxjobs", help="\
            maximum numjobs to graph in 3d graph", nargs='?', default=64, type=int)
    ag.add_argument("-n", "--numjobs", nargs='+', help="\
            specifies for which numjob parameter you want the 2d graphs to be\
                 generated", default=[1], type=int)
    ag.add_argument("-r", "--rw", choices=['read', 'write', 'randread', 'randwrite', 'randrw'],
                    help="read/write mode randread/randwrite")
    ag.add_argument("-m", "--max", default=None, type=int,
                    help=" optional max value for z-axis")
    ag.add_argument("--max-y", help=" optional max value for y-axis")
    ag.add_argument("-g", "--loggraph", action='store_true',
                    help="Create graph based on raw log data")
    ag.add_argument("-e", "--moving-average", default=None, type=int,
                    help="The moving average helps to smooth out graphs,\
                         the argument is the size of the moving window\
                              (default is None to disable)")
    ag.add_argument("-T", "--type", nargs='+', help="\
            type should be iops,bw,lat,clat,slat", type=str,
                    choices=['bw', 'iops', 'lat', 'slat', 'clat'])
    ag.add_argument("-f", "--filter", nargs='+', help="\
            filter should be read/write/rw", type=str, default=('read', 'write'),
                    choices=['read', 'write'])

    return parser


def main():
    settings = {}
    parser = set_arguments()
    try:
        args = parser.parse_args()
    except OSError:
        parser.print_help()
        sys.exit(1)

    if len(sys.argv) == 1:
        parser.print_help()
        sys.exit(1)

    settings = vars(args)

    if settings['loggraph']:
        benchmarkfiles = logdata.listFioLogFiles(settings['input_directory'])
        logfiles = logdata.filterLogFiles(settings, benchmarkfiles)
        rawdata = logdata.readLogDataFromFiles(settings, logfiles)
        merged = logdata.mergeDataSet(settings, rawdata)
        graph.chart_2d_log_data(settings, merged)

    if settings['latency_iops_3d']:
        list_of_json_files = jsonimport.list_json_files(settings)
        dataset = jsonimport.import_json_dataset(list_of_json_files)
        parsed_data = jsonimport.get_flat_json_mapping(dataset)
        bar3d.plot_3d(settings, parsed_data)

    #    b.chart_3d_iops_numjobs('randread','iops')
    #    b.chart_3d_iops_numjobs('randwrite','iops')
    #    b.chart_3d_iops_numjobs('randread','lat')
    #    b.chart_3d_iops_numjobs('randwrite','lat')

    if settings['latency_iops_2d']:
        list_of_json_files = jsonimport.list_json_files(settings)
        dataset = jsonimport.import_json_dataset(list_of_json_files)
        parsed_data = jsonimport.get_flat_json_mapping(dataset)
        # pprint.pprint(parsed_data)
        bar2d.chart_2dbarchart_jsonlogdata(settings, parsed_data)

        # if settings['histogram']:
        #    b.chart_latency_histogram('randread')
        #    b.chart_latency_histogram('randwrite')

        # if not settings['histogram'] and not settings['latency_iops_2d'] and not settings['latency_iops_3d']:
        #    parser.print_help()
        #    print("Specify -L -l, -H or all of them")
        #    exit(1)


if __name__ == "__main__":
    main()
